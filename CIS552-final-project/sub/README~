Genetic Algorithm Program - By Patrick Yeo Ho Yoon yeyoon & Mark Smyda msmyda

(1) Additional Libraries that the projects depends on.

 - GetOpt
 - MonadRandom (Control.Monad.Random)
 - QuickCheck, Monadic QuickCheck (Test.QuickCheck.Monadic)
 - HUnit (System.Console.GetOpt)
 - Text.Printf
 - Control.Applicative

(2) List of source files

 - Chrom.hs 
     * Definition of Chromosome Data
     * Crossover Methods for Chromosome. Numbers indicate option number for execution (will be explained below).
        1. One Pivot Crossover, Use Two Children (Default) : Cross-over on one pivot. Use both resulting children for next generation.
        2. One Pivot Crossover, Use One Child : Cross-over on one pivot. Use only one resulting child for next generation.
        3. Two Pivot Crossover, Use Two Children : Same as 1., but crossing over on two pivots.
        4. Random Pivot Crossover : Multiple Pivots are chosen randomly. Use both children for next generation.
                                    Each two genes from two parents are assigned randomly to two children. 
     * Mutation Methods for Chromosome. Numbers indicate option number for execution (will be explained below).
        1. Random Character Switch Mutation : One character is switched to a random character in a random position.
        2. Swap Two Genes Mutation : Two randomly chosen genes are swapped in a chromosome
     * Fitness function : Defined as closeness to the target (Sum of differences of ASCII numbers)
     * QuickCheck Property for mutation & crossover functions
     * Random chromosome generation function and QuickCheck property
 - GAConfig.hs
     *  Contains data for Genetic algorithm configurations and show instance.
     *  Crossover Option : {xoverGetTwo = 1, xoverGetOne = 2, xoverTwoPivot =3, xoverRandomPick = 4}                  
     *  Mutation Option : {mutate = 1, mutateSwap =2}             
     *  Selection Option : {tournaSelect = 1, fitPropSelect = 2}  
 - Helper.hs : Contains all helper functions for all other modules. 
 - Pop.hs
     * Definition of Population data with parameters:
       1. Elitism Ratio : ratio of % of fittest population carried over to the next generation without any manipulation.
       2. Crossover Ratio : The proportion of the rest of the population that goes through crossoever. 
                            The reminder is copied over directly.
       3. Mutation Ratio : Mutation ratio : In either case of crossover or direcy copy, each of next generation chromosomes 
                           goes random mutation based on the mutation ratio. 
       4. Initial Population Size
       5. Maximum number of Generation.
     * Random population initialization function, QuickCheck Property
     * Parents Selection Methds : Numbers indicate option number for execution (will be explained below).
       1. Tournament Selection : Pick k elements randomly from population and pick the fittest one.
       2. Fitness Ranking Based Selection : Pick k elements randomly from population and pick one with probability 
                                            inversely proportional to the ranking in the k-pool.
     * Population evolution method.
  - Main.hs
     * Main function to execute the program and runQuickChecks to run all QuickChecks.
     * The options are 

  -i <initial population size>  --initpopsize=<initial population size>  How many candidate strings should be initialized in the population
  -e <elitism ratio>            --eliRatio=<elitism ratio>               What proportion of candidates continues to next gen without change
  -m <mutation ratio>           --mutRatio=<mutation ratio>              What proportion of candidates is chosen for random mutation
  -x <crossover ratio>          --xoverRatio=<crossover ratio>           The proportion of strings that undergoes crossover
  -t <tournament size>          --tournaSize=<tournament size>           The size of the tournament in selecting parent genes from population
  -g <maximum generations>      --maxGen=<maximum generations>           The maximum number of generations to attempt before quitting
  -v <crossover option>         --xoverOption=<crossover option>         Crossover Method Option. Read README file for list of options.
  -u <mutation option>          --mutOption=<mutation option>            Mutation Method Option. Read README file for list of options.
  -s <selection option>         --selOption=<selection option>           Selection Method Option. Read README file for list of options.
  -b                            --BinTar                                 Whether or not to use binary representation for target
  -r <target>                   --target=<target>                        The string to which we should attempt convergence


For example the command "./Main -b -i 10" will give the result, 

Reached target at gen 1315: Chrom {gen = 1315, fit = 0, gene = "100100011000011110011110101111001011101100110110010000011010011110011100000110011011101011101110101110"}
Initial Population Size : 10
Elitism Ratio : 0.5
Crossover Ratio : 0.2
Mutation Ratio : 1.0e-2
Tournament Size : 3
Crossover Method : One Pivot Crossover, Use Two Children
Mutation Method : Random Character Switch Mutation
Selection Method : Tournament Selection

---- Here are our some of our answers for the questions to be asked at the presentation (Rest of them will be answered at the presentaion)----

 - What are the main modules of your program? Why did you divide them up in this way?

The main modules of our program are functions concerning the way crossovers are done, the way mutations are done, and the mechanisms by which populations evolve toward the target. Crossover functions include 
xoverGetOne, which produces a single child offspring by selecting alternatively from two parents split by a random pivot, xoverGetTwo, which makes two children from the single pivot, xoverTwoPivot, which makes two 
children from alternative selection between two pivots, and finally xoverRandomPick, which makes two children from alternatively selecting among multiple random crossover points. These attempt to expedite solution 
convergence by mixing and matching the more correct portions of candidates. Mutation functions are mutate, which puts a random character in a random position, and mutateSwap, which swaps the characters from two randomly 
chosen positions in the gene. These functions are responsible for generating movement in the solution space. Finally, our last set of functions are fitness, genRandom, selParents, randomPop, tournaSelect, fitPropSelect, 
evolveOne, evolve, repeatWhile, and terminate. All of these functions serve the purpose of traversing the gradient toward the solution (which has maximum fitness). This module sets up populations, performs crossovers, 
preserves genes close to solution, and iterates the process through multiple generations. We chose to divide up the modules in such fashion because each is independently defined and executed in sequence per generation. 
That is, crossovers are done in a self-contained step, mutations are done in a self-contained step, and the final module consists of performing the functions in the other two modules, evaluating fitness, and pushing the 
most fit strings along in iteration.

- Are there any parts of the code that you are particularly proud of? Where did you spend the most time polishing your implementation? What did it look like before? (In preparation for this question, you may want to have the the old version in comments available for comparison.)

We are particularly proud of our crossover functions and the fitness proportionate selection. The crossover functions cleanly perform alternative selection from the parents by combining the take and drop functions,
which is an effective way of parsing chunks reminiscent of piping together the modular head and tail functions in unix operating systems to make windowed selections on file contents. Additionally, the fitness 
proportionate selection is an interesting use of randomization in choosing members to continue to successive generations. We spent the most time polishing 

- What sort of testing did you do to verify the correctness of your code? (Unit tests, quickcheck properties, etc.)

We implemented a number of quickcheck properties for the crossover functions, mutate functions, and the genRandom and randomPop functions. Additionally, we used unit tests to verify the correctness of the fitness 

- What parts of your project correspond to something that we talked about in class?

We made extensive use of QuickCheck, something discussed in class at length. We made use of custom data structures including Flag, Chrom, Pop, and PopInfo. Monads were used, mostly in conjunction with the do notation, 
and higher order functions foldr and map were explicitly used, along with the function concatenation syntax '.' These were used throughout the project. Also we used Control.Applicative to make it look clear for some functor use.

If you reimplemented this project in another language, what language would you choose? What would be easier? What would be more difficult?

We would choose python for implementation of the project in another language. The object oriented and imperative paradigm would facilitate structuring genes within populations, letting us store the fitness of each 
string within the object. Additionally, mutation by swapping would be much more concisely implemented. Conversely, 
